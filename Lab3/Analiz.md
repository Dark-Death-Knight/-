### 1. Ключевые операции и передаваемые данные
### 1.1. Просмотр каталога и поиск
Операция: Пользователь открывает приложение, просматривает ленту товаров, использует поиск и фильтры.

Клиент → Сервер (Запрос):

GET /api/v1/homepage (для главной)

GET /api/v1/search?query=телефон&sort=popular&filters[price][from]=10000&filters[price][to]=50000

Заголовки: User-Agent, Authorization: Bearer <token> (если пользователь авторизован)

Сервер → Клиент (Ответ):

Данные:

Массив товаров: { product_id, name, price, discount_price, rating, feedback_count, seller_name, thumbnail_url, is_favorite }

Пагинация: { current_page, total_pages, total_items }

Данные для фильтров: { available_filters: [brands, colors, sizes, price_range] }

Мета-данные: status: 200, cache-control

Моменты для улучшения:

Использование CDN: Изображения товаров (thumbnail_url) должны отдаваться через CDN для снижения задержки.

Оптимизация поиска: Для поисковых запросов можно использовать технологию Edge Side Includes (ESI) или отдельный сервис полнотекстового поиска (Elasticsearch) на граничных серверах, чтобы обрабатывать запросы ближе к пользователю.

Предзагрузка данных: Можно предзагружать следующие страницы каталога при прокрутке, но не агрессивно, чтобы не тратить трафик пользователя.

### 1.2. Просмотр карточки товара
Операция: Пользователь нажимает на товар, чтобы увидеть детали.

Клиент → Сервер (Запрос):

GET /api/v1/products/123456

Заголовки: Authorization (если есть)

Сервер → Клиент (Ответ):

Данные:

Детали товара: { product_id, name, full_description, price, discount_price, rating, feedback_count, seller_info, characteristics: [{key, value}], available_quantity }

Галерея изображений: [image_url_highres_1, ...]

Отзывы: [{ user_name, rating, comment, date, likes }] (часто подгружаются отдельно)

Похожие товары: [{product_id, name, price, ...}]

Мета-данные: status: 200

Моменты для улучшения:

Разделение эндпоинтов: Основная информация о товаре, отзывы и похожие товары часто загружаются отдельными запросами. Это позволяет быстрее показать основную страницу, но увеличивает общее число запросов. Нужен баланс — использовать GraphQL для получения только нужных данных одним запросом.

Кэширование на уровне фрагментов: Характеристики товара редко меняются, их можно aggressively кэшировать. Отзывы меняются чаще, их TTL (Time To Live) должен быть меньше.

### 1.3. Работа с корзиной
Операция: Добавление товара в корзину, изменение количества, удаление.

Клиент → Сервер (Запрос):

POST /api/v1/cart/items { "product_id": 123456, "quantity": 2 }

PATCH /api/v1/cart/items/123456 { "quantity": 1 }

DELETE /api/v1/cart/items/123456

Заголовки: Обязательно Authorization: Bearer <token>

Сервер → Клиент (Ответ):

Данные: Обновленное состояние корзины: { total_items, total_price, discounted_price, items: [{ product_id, name, quantity, price_per_item, total_price }], applied_promos }

Мета-данные: status: 200 (успех), status: 401 (не авторизован)

Моменты для улучшения:

Офлайн-корзина: Приложение не позволяет добавлять товары в корзину без сети. Можно реализовать локальное хранилище на устройстве с последующей синхронизацией при появлении соединения.

Использование Redis: Корзина — идеальный кандидат для хранения в Redis (in-memory data store) из-за частых операций записи/чтения и временного характера данных.

### 1.4. Оформление и оплата заказа
Операция: Пользователь переходит к оформлению, выбирает адрес и способ оплаты, подтверждает заказ.

Клиент → Сервер (Запрос):

GET /api/v1/checkout — получение финальной суммы, доступных способов доставки и оплаты.

POST /api/v1/orders { "cart_items": [...], "shipping_address_id": 789, "payment_method_id": "card_xxx" }

Сервер → Клиент (Ответ):

Данные:

На шаге 1: { final_price, available_addresses, available_payment_methods }

На шаге 2: { order_id: 987654, status: "processing", payment_confirmation_url: "https://payment-gateway/..." } (для безальноготной оплаты)

Моменты для улучшения:

Idempotency Key (Ключ идемпотентности): При создании заказа сеть может оборваться, и пользователь отправит запрос повторно. Чтобы не создать два одинаковых заказа, клиент должен генерировать уникальный idempotency_key и отправлять его с каждым запросом на создание заказа. Сервер будет игнорировать повторные запросы с тем же ключом.

Асинхронная обработка заказа: Создание заказа должно быть асинхронной операцией. Сервер сразу возвращает order_id со статусом "processing", а затем через WebSocket или Push-уведомление сообщает о смене статуса ("confirmed", "shipped").

### 1.5. Отслеживание заказа
Операция: Пользователь просматривает статус своих заказов в личном кабинете.

Клиент → Сервер (Запрос):

GET /api/v1/orders

GET /api/v1/orders/987654

Сервер → Клиент (Ответ):

Данные:

Список заказов: [{ order_id, created_date, total_price, status: "delivered", tracking_url }]

Детали заказа: { ... , status_history: [{status, datetime}], current_position: "Moscow_sorting_center" }

Моменты для улучшения:

Server-Sent Events (SSE) / WebSockets: Вместо постоянных опросов сервера (GET /api/v1/orders/987654) каждые 10 секунд, можно установить одно постоянное соединение, по которому сервер будет сам отправлять клиенту обновления статуса. Это снижает нагрузку на сервер и делает обновления мгновенными.

